
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

Before - categorise_recent_bins  time:   [16.049 µs 16.655 µs 17.401 µs]
After - categorise_recent_bins   time:   [2.5298 ns 2.5693 ns 2.6210 ns]
                        change: [-99.986% -99.985% -99.985%] (p = 0.00 < 0.05)
                        Performance has improved.
Found 11 outliers among 100 measurements (11.00%)
  5 (5.00%) high mild
  6 (6.00%) high severe

1) Pre-change, iterating over the vector to check if timestamp within last 5 seconds
/*  
    fn categorise_recent_bins(& mut self, seconds_interval: u128) {

        let current_timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_millis();
    
    //println!("The current timestamp is: {}", current_timestamp);

    let temp = self.x_stats.iter()
        .filter(|bin| current_timestamp - bin.timestamp <= seconds_interval)
        .cloned()
        .collect::<Vec<Bin>>();

    //println!("Points collected to far {}", temp.len());
    // for bin in temp {
    //     print!("{}, ", bin.get_mean());
    // }
    //println!("\n");

    }*/

2) Post-change, upon async tick record index -- see how Performance improves-no need to iterate
fn categorise_recent_bins(& mut self, seconds_interval: u128) {

        let length: usize = self.x_stats.len();
        let temp = self.x_stats[self.seconds_length..].to_vec();
        // for bin in temp {
        //     print!("{},", bin.get_mean() );
        // }
        self.seconds_length = length;

        //println!("\n");
}